%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Plantilla TFG/TFM
% Escuela Politécnica Superior de la Universidad de Alicante
% Realizado por: Jose Manuel Requena Plens
% Contacto: info@jmrplens.com / Telegram:@jmrplens
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusiones}
\label{conclusiones}
Los distintos hitos que se han conseguido a lo largo de este proyecto han sido, por orden cronológico, en primer lugar, la creación de un motor gráfico que es capaz de dibujar entidades en una ventana, tanto siendo \textit{sprites} en formato \gls{png} como siendo formas rectangulares que simbolizan el personaje. Además, este motor es capaz de manejar diferentes sistemas de un juego, de forma totalmente desacoplada del código del motor. Es decir, que el usuario que quisiera utilizar el motor como una librería podría implementar tantos sistemas como quisiera, puesto que el motor proporciona las herramientas necesarias para gestionar entidades y componentes de cualquier tipo para estas. Con esto se demuestra que ha quedado totalmente comprendido el motor \gls{ecs}, tanto el funcionamiento como la implementación del mismo. 
\\
Más concretamente, en este proyecto se han desarrollado los sistemas de ``Render'' encargado de abrir la ventana y dibujar sobre ella, ``Collision''  encargado de gestionar las colisiones entre las diferentes entidades que tengan el componente correspondiente, ``Physics'' que se encarga de actualizar y gestionar las posiciones de las distintas entidades que contengan el componente correspondiente, ``ArtificialInteligence'' que se encarga de responder en el juego con las acciones que decide la \gls{ia}, entre otros.

En segundo lugar, se ha conseguido la comprensión de diferentes formas de optimizar la velocidad de un programa, utilizando técnicas de alineamiento de la caché. Esto se ha utilizado en el motor, pero además en el apartado de resultados (apartado \ref{resultados}) se ha demostrado de una manera sencilla y entendible con unos conocimientos mínimos sobre programación que esto efectivamente es verdad, ejecutando el test distintas veces para obtener los resultados empíricamente.

En tercer lugar se ha desarrollado un juego funcional, tratándose de un juego basado en el famoso Pong, con diferentes añadidos para darle complejidad. De esta manera he conseguido entender cuáles son las dificultades de hacer un juego, cómo se añaden funcionalidades al mismo, y se ha demostrado que el motor previamente desarrollado es aplicable a un juego. Además este juego ha servido para poder aplicar distintas técnicas de \gls{ia} que mencionaré a continuación.

El cuarto hito, que no pertenecía a los objetivos, pero se ha dado durante el desarrollo ha sido la renderización de texto para el desarrollo de menús. Esto es algo común a una gran cantidad de software pero no fue planteado hasta llegado el momento de hacer menú para el juego porque es algo que das por hecho que tendrá la mayoría de aplicaciones. Para esta tarea utilicé la librería stb\_truetype\footnote{Puede ser encontrada en \url{https://github.com/nothings/stb/blob/master/stb_truetype.h}}, que simplemente ayuda a conseguir el conjunto de bytes que conforman el texto renderizado. Pero después de obtener el texto tuve que dibujarlo en la ventana, por lo que tuve que retocar el sistema de ``Render'', y hacer que el menú respondiese a la interacción con el usuario. Sin embargo, aunque este trabajo no quedó en vano porque se consiguió renderizar texto y hacer menús con un uso mínimo de librerías, posteriormente esta tarea fue cambiada por la librería Dear ImGui \footnote{Puede ser encontrada en \url{https://github.com/ocornut/imgui}} que me permitió hacer menús más complejos para ajustar la \gls{ia}, creando un entorno de entrenamiento de desarrollo propio.

El quinto hito fue desarrollar una \gls{ia} que fuese capaz de aprender mediante \gls{ml}. En primera instancia desarrollé un perceptrón, que es el modelo de aprendizaje más básico, con un algoritmo de aprendizaje aleatorio. En realidad el juego utilizaba dos perceptrones por cada jugador, uno para decidir si pulsar hacia arriba y otro para decidir lo hace hacia abajo. Este agente era capaz de jugar de una manera satisfactoria y responder con una dificultad media para enfrentarse contra un humano. 
\\
Después de comprobar el correcto funcionamiento del perceptrón, desarrollé una red neuronal, la cual es capaz de aprender de igual manera que el perceptrón, pero puede aprender información más compleja, debido a las capas intermedias. El problema es que utilizar un algoritmo aleatorio para entrenar una red neuronal puede no ser lo más apropiado ya que, por lo general, estas están formadas por un número mucho mayor de términos independientes (en el caso del perceptrón y red neuronal, sus pesos). En solución a ello implementé el algoritmo conocido como \textit{backpropagation}, que consigue que la red aprenda más rápido utilizando la teoría del descenso por gradiente. Una vez implementado en el juego comprobé que la red neuronal responde de una manera menos satisfactoria que el perceptrón en este juego en concreto. Es posible que esto sea porque se aporta información irrelevante para la red, porque la complejidad de este juego es muy baja, o porque obtener un conjunto de datos sin ruido (fallos como por ejemplo, no pulsar cuando lo correcto es que el agente sí pulse una de las teclas) es demasiado difícil. Por lo tanto, la conclusión es que el perceptrón funciona mejor en este juego.
\\
Además de estas dos \gls{ia}, también he desarrollado una \gls{ia} diseñada, para que el jugador pueda enfrentarse a ella cuando no dispone de ningún archivo de pesos para asignar a una red neuronal. En este caso no requiere de aprendizaje, ya que es diseñada, y sigue un algoritmo de creación propia.

Por último, se ha conseguido entender y documentar todas las tecnologías implementadas en el proyecto. De esta manera, la persona que necesite entender cómo funcionan, puede acudir a esta memoria para comprenderlas.

\section{Valoraciones personales}
Una vez planteadas las conclusiones subjetivas, voy a dar mis conclusiones objetivas. La primera decisión fue desarrollar yo mismo el motor del videojuego, en lugar de usar uno ya existente, evitando el uso de librerías externas para conocer a fondo cómo se crea un motor de videojuegos. Como experiencia de aprendizaje, ha sido algo fructífero, pero al mismo tiempo me ha quitado tiempo de desarrollo. No solo hay que tener en cuenta que hasta noviembre no terminé el motor, sino que el hecho de hacerlo yo mismo ha llevado a tener que modificar partes del código para que funcione en otros sistemas operativos, tener que cambiar el sistema de ``Render'' puesto que para hacer los menús me convenía poder usar otras herramientas, etc. Todos estos inconvenientes que sumados forman una parte importante del desarrollo de este proyecto, no habrían surgido y ese tiempo del desarrollo podría haber sido destinado a ampliar otras partes del proyecto que se han quedado con carencias, que posteriormente mencionaré. 
\\
Por lo tanto, las ventajas son claras, el objetivo era descubrir cómo se hacía un motor de videojuegos desde cero, y eso he hecho, comprendiendo y explicándolo en el apartado de desarrollo (apartado \ref{desarrollo}). Los inconvenientes han sido mayormente uno, el tiempo. Por supuesto, otro inconveniente a destacar podría ser que los motores ya existentes te ofrecen herramientas para que el juego quede más profesional, pero como ya he mencionado anteriormente, el objetivo del proyecto no era tener un juego con acabados profesionales, y la parte que me atañe respecto al desarrollo del motor puedo afirmar que ha acabado de manera satisfactoria.

Respecto a la optimización de la caché, utilizando los resultados que obtuve al hacerlo de forma aislada con test creados por mí, me di cuenta de que los ordenadores están tan avanzados que son demasiado complejos como para determinar con mis conocimientos qué es más eficiente y qué no. Como has visto en el apartado de resultados (apartado \ref{resultados}), finalmente demostré que leer la memoria linealmente era más rápido, pero el primer test que pensaba que afirmaría este pretexto fue fallido. Por lo que soy incapaz de decir si verdaderamente las decisiones de optimización de caché tomadas durante el desarrollo del proyecto han sido beneficiosas o no, para ello habría que desarrollar un sistema distinto de organización de entidades y componentes en memoria, y de esta manera compararlo con el ya existente, para demostrar empíricamente que fueron decisiones bien tomadas.

El juego ha terminado conforme se planteó al principio, un juego en el que puedes entrenar a un agente y ponerlo a jugar contra otros agentes. Sin embargo, no he terminado de añadir todas las funciones que quería en él. Debido a que el tiempo del desarrollo del \gls{tfg} está a punto de terminar, he tenido que limitar las características del juego para poder entregar el \gls{tfg} dentro de plazo. Aún así, ha terminado siendo algo de lo que estar orgulloso.

En cuanto a la \gls{ia}, he llegado a la conclusión de que el perceptrón resolvía mejor el problema de jugar a este juego que la red neuronal. Puede ser, en parte, porque es un juego bastante simple que sólo consta de pulsar abajo o arriba, por lo tanto el perceptrón entrenado de forma aleatoria, con la poca cantidad de pesos que tiene, puede encontrar una solución funcional. La red neuronal, al ser un sistema más complejo, con un mayor número de términos independientes aprende mediante \textit{backpropagation}, pero puede que haya demasiado ruido en las muestras, y por eso no sea el algoritmo más apropiado para hacer aprender a la red. Sin embargo, es un punto más interesante para el usuario final, poder ajustar los parámetros del entrenamiento de la \gls{ia}, por eso he decidido dejar la red neuronal dentro del juego, porque es más interesante ajustarlos tú mismo, que simplemente apretar un botón y ver cómo avanza el entrenamiento aleatorio sin ajustar nada.
\\
Me gustaría añadir que, aunque la red neuronal implementada junto con el algoritmo de \textit{backpropagation} no cumpliese con el objetivo de jugar muy bien al juego debido a los problemas ya mencionados, esta es una red neuronal totalmente funcional, implementada desde cero por mí, y es aplicable a cualquier otro proyecto que requiera de \gls{ml}, así que en ese sentido acabo muy contento, con todos los objetivos personales cumplidos.